Author: Yan Zhuang and Yu Deng


1) Pour nous, on a pensé deux méthodes pour vérifier si les variables sont bien initialisées.	a) Dans une fonction, soit verifierVariables(), on ajoute une condition "if" dans lequel on vérifie si chaque variable n'égale pas à "null" (surtout, on sait que chaque variable ne sera pas attribuée avec une valeur de null selon l'énoncé. Donc si une variable a une valeur de null, cela veut dire que cette variable n'a pas été initialisée ). Si aucune variable n’égale à "null", cela veut dire que toutes les variables sont bien initialisées.	b) On crée d'abord un HashMap<String,Boolean> qui va stocker chaque variable qui est initialisée. (Par défaut, ce Map aurait le nom de chaque variable comme clé, et False comme valeur de défaut).Dans chaque setter, on va ajouter une ligne de code qui va ajouter cette variable dans ce Map (bien sûr, cela se fera après qu'on aurait vérifié si la valeur de chaque variable est valide selon notre contrainte imposée sur chaque variable), et on va aussi changer la valeur Boolean de False à True pour signifier que la variable est bien initialisée et validée.À la fin, avant de créer une instance de Plante, on vérifie s'il existe une ou plusieurs False dans ce Map. (Cela signifie qu’une ou plusieurs variables ne sont pas initialisées). S'il n'y en a aucun, cela veut dire que toutes les variables sont initialisées, et on peut bien créer l'instance de Plante.	c) On a choisi la deuxième façon, parce qu'on pense que cette méthode est plus élégante et plus pratique que de taper plusieurs fois "<variable> != null" lié par plusieurs "&&" dans une seule condition "if". Surtout, vu qu'on doit hériter les classes, ça serait plus pratique d'implémenter une telle méthode pour faciliter l'héritage et la vérification dans le futur.2) Quand on programme le Lac pour simuler la vie d'une plante, on décide de traiter la vérification de condition dans "Lac.java" où on a aussi ajouté des méthodes pour faciliter la vérification. (Par exemple, le calcul de l'énergie absorbée par la plante, le calcul de la chance de survivre)Toutefois, quand il s'agit d'un traitement qu'on doive changer la valeur d'un paramètre d'une plante, on le réalise dans "Plante.java" (c'est en fait dans Organisme.java dont les méthodes sont héritées par Plantes.java) où on ajoute des méthodes pour appliquer les changements (par exemple, retirer de l'énergie, ajouter de l'énergie ou incrémenter l'âge par un après chaque cycle). Aussi, pour la méthode qui crée un enfant en particulier, on décide de le mettre dans leur propre classe. D'après nous, on pense que la création d'un enfant est la responsabilité de leur propre espèce, pas celle du lac. (Par contre, la vérification se fait dans Lac.java où on a vérifié si, dans chaque cycle, cet organisme va créer un enfant). On a donc créé deux méthodes pour chaque classe (createOrganismeBaby()/createPlanteBaby()). 	Particulièrement, la méthode "createPlanteBaby()" va appeler d'abord "createOrganismeBaby()" qui va créer un organisme (vu qu'on a des paramètres en commun). Étant donné que les paramètres partagés par Plante et Organisme sont exactement les mêmes, et grâce au constructeur qu'on a déjà créé qui peut créer une nouvelle instance de Plante à partir d'un organisme, on crée simplement une nouvelle instance de Plante. On les met dans la classe Plante et Organisme au lieu dans leur propre usine parce que quand on crée un enfant, on a déjà tous les paramètres, donc on n'a pas besoin de créer l'instant à travers de l'usine qui sert principalement à vérifier si toutes les variables sont bien initialisées avant de créer une nouvelle instance.	Dans notre avis, vu que le lac c'est où la simulation se passe. Donc, les vérifications doivent se faire dans Lac.java au lieu dans Plantes.java. En prenant l'exemple de notre devoir 1, quand on doit vérifier la transaction, ça se fait dans Bank.java (comme Lac.java). La vérification ne doit pas se faire dans Branch.java (comme plantes.java) parce que c'est où on doit effectuer le traitement après la vérification.3) On a choisi de créer une classe Organisme au lieu d'interface pour que le constructeur et les autres méthodes puissent être hérités aussi. Dans notre avis, il existe trop de similarités entre Plantes.java et Herbivores.java, donc si on utilise une interface, on aurait à écrire plusieurs fois les mêmes méthodes. En créant une classe Organisme, on évite de les écrire plusieurs fois. Cela nous facilite aussi, dans le futur, de la création d'une nouvelle instance sans besoin de spécifier les mêmes paramètres plusieurs fois.4) Comme la question précédente, on a aussi créé une nouvelle superclasse UsineOrganisme.java. Vu que UsinesOrganisme.java se base presque complètement sur l'ancienne version de UsinePlante.java, on a pu retirer la plupart de code de UsinePlante.java. Pour UsineHerbivores.java, on n'a qu'à ajouter des setters pour les variables supplémentaires.Vu qu'on a une méthode spéciale pour vérifier si toutes les variables sont bien initialisées et qu'il existe des paramètres supplémentaires dans Herbivores.java, on a dû override cette méthode (Grâce à super()) en ajoutant un bloc de code qui vérifie si "voraciteMin" est inférieur ou égal à "voraciteMax".Étant donné qu'on doit créer une méthode "creerPlante()" et "creerHerbivore()", on a trouvé une façon de le faire, mais sans besoin d'appeler plusieurs fois "getXXX()". On a créé, dans la classe "UsineOrganisme", la méthode "creerOrganisme" qui va retourner un objet Oragnisme avec les paramètres qui existent déjà dans "Organisme". Dans "Plante.java", on a créé un nouveau constructeur qui peut prendre simplement un objet de type Organisme comme paramètre. Par conséquent, dans "UsinePlante.java", on a créé la méthode "creeerPlante()" qui appelle "verifierCondition()" puis "creerOrganisme()" qui nous retourne un objet Oragnisme et à la fin, on l'utilise pour initialiser un nouvel objet Plante (surtout vu que la Plante et l'Organisme ont les mêmes paramètres). 	De façon similaire, on fait la même chose pour "Herbivore". Toutefois, cette fois-ci, vu qu'on a des paramètres supplémentaires, le constructeur prendre un objet Organisme ainsi que les paramètres supplémentaires. Une méthode "creerHerbivore()" a aussi été créée.5) On n’a pas changé la stratégie. Du même principe, toutes les vérifications et les méthodes "helper" (Ex. : Trouver l'espèce en cherchant le nom) se sont faites dans "Lac.java" vu que c'est notre environnement de la simulation. Les autres classes individus, soit Plantes/Carnivore/Herbivore, sont utilisés quand on a besoin de changer les paramètres internes. Aussi, du même principe, on a créé une nouvelle méthode "createHerbivoreBaby()" qui va appeler d'abord "createOrganismeBaby()" et puis créer une nouvelle instance à partir de l'organisme généré et des autres paramètres supplémentaires pour Herbivore. Cette méthode a aussi été placée dans la classe Herbivore au lieu dans sa propre usine.6) On aurait pu réutiliser le code vu qu'il y a beaucoup de paramètres en commun, notre stratégie originale est présentée ci-bas. Toutefois, on vient de découvrir que la méthode skipEndTag() qui nous empêche de faire ça. Vu que ce n'est pas nous qui écrivons, ce code et le mécanisme utilisé dans ConditionsInitiales.java sont un peu compliqués, on a décidé à la fin de ne pas réutiliser le code. On a simplement trois méthodes: creerPlante()/creerHerbivore()/creerCarnivore(), qui lisent les paramètres en commun ainsi que les paramètres supplémentaires. On croit que c'est mieux de faire cela au lieu de changer le mécanisme de ConditionsInitiales.java qui peut provoquer d'autres erreurs, et qui va compliquer notre tâche.	Réponse originale: On a décidé de réutiliser partiellement les codes. On a bien vu des codes répétitifs dans la création d'une plante, d'un herbivore et d'un carnivore vu qu'ils sont des paramètres en commun. Par conséquent, on a décidé de créer d'abord un organisme, et puis de créer leur propre instance (une plante, un herbivore ou un carnivore) à partir de l'organisme généré. Par conséquent, on n'a pas besoin de réécrire plusieurs fois "usine.setNomEspece()" par exemple. Toutefois, dû ce fait, on a dû changer un peu le code pour UsinePlante/Carnivore/Herbivore. On a bien overload la fonction creerPlante/Herbivore/Carnivore pour qu'il prenne un objet "Organisme" comme paramètre afin de créer une instance de plante/herbivore/carnivore directement à partir de cet organisme. On a aussi dû overload la fonction "verifyCondition" parce qu'on a déjà créé un organisme qui a déjà tous les paramètres en commun, et on n'a pas besoin de les vérifier. On croit bien que les codes pourraient être plus élégants que cela, mais avec notre connaissance de Java, ça serait un peu difficile pour nous sans utiliser des fonctions qu'on ne comprend même pas.